/* Stellarium Web Engine - Copyright (c) 2018 - Noctua Software Ltd
 *
 * This program is licensed under the terms of the GNU AGPL v3, or
 * alternatively under a commercial licence.
 *
 * The terms of the AGPL v3 license can be found in the main directory of this
 * repository.
 */

#include "swe.h"

core_t *core;   // The global core object.

#define CORE_MIN_FOV (1./3600 * DD2R)

static void core_on_fov_changed(obj_t *obj, const attribute_t *attr)
{
    // For the moment there is not point going further than 0.5Â°.
    projection_t proj;
    core_get_proj(&proj);
    core->fov = clamp(core->fov, CORE_MIN_FOV, proj.max_fov);
}

static void core_on_utcoffset_changed(obj_t *obj, const attribute_t *attr)
{
    core->utc_offset = clamp(core->utc_offset, -24 * 60, +24 * 60);
}

static void add_progressbar(void *user, const char *id, const char *label,
                            int v, int total)
{
    json_value *array = user, *val;
    val = json_object_new(0);
    json_object_push(val, "id", json_string_new(id));
    json_object_push(val, "label", json_string_new(label));
    json_object_push(val, "total", json_integer_new(total));
    json_object_push(val, "value", json_integer_new(v));
    json_array_push(array, val);
}

static json_value *core_fn_progressbars(obj_t *obj, const attribute_t *attr,
                                        const json_value *args)
{
    json_value *ret;
    ret = json_array_new(0);
    progressbar_list(ret, add_progressbar);
    return ret;
}

static obj_t *core_get(const obj_t *obj, const char *id, int flags)
{
    obj_t *module;
    obj_t *ret;
    DL_FOREACH(core->obj.children, module) {
        if (module->id && strcmp(module->id, id) == 0) return module;
        ret = obj_get(module, id, flags);
        if (ret) return ret;
    }
    return NULL;
}

EMSCRIPTEN_KEEPALIVE
obj_t *core_get_module(const char *id)
{
    int len;
    const char *end;
    obj_t *m, *ret = (obj_t*)core;

    // Make the first 'core' optional.
    if (strcmp(id, "core") == 0) return (obj_t*)core;
    if (strncmp(id, "core.", 5) == 0) id += 5;

    while (*id) {
        end = strchr(id, '.') ?: id + strlen(id);
        len = end - id;
        DL_FOREACH(ret->children, m) {
            if (!m->id) continue;
            if (strncmp(m->id, id, len) == 0 && m->id[len] == '\0') {
                ret = m;
                id += len;
                if (*id == '.') id++;
                break;
            }
        }
        if (!m) return NULL;
    }
    return ret;
}

static obj_t *core_get_by_oid(const obj_t *obj, uint64_t oid, uint64_t hint)
{
    obj_t *module;
    obj_t *ret;
    DL_FOREACH(core->obj.children, module) {
        ret = obj_get_by_oid(module, oid, hint);
        if (ret) return ret;
    }
    return NULL;
}

static int core_list(const obj_t *obj, observer_t *obs,
                     double max_mag, uint64_t hint, void *user,
                     int (*f)(void *user, obj_t *obj))
{
    // XXX: won't stop if the callback return != 0.
    obj_t *module;
    int nb = 0;
    DL_FOREACH(core->obj.children, module) {
        nb += module_list_objs(module, obs, max_mag, hint, user, f);
    }
    return nb;
}

static int core_add_data_source(obj_t *obj, const char *url, const char *type,
                                json_value *args)
{
    obj_t *module;
    int r;
    DL_FOREACH(core->obj.children, module) {
        if (!(module->klass->flags & OBJ_MODULE)) continue;
        r = module_add_data_source(module, url, type, args);
        if (r == 1) continue; // Can't add here.
        return r;
    }
    return 1;
}

static int modules_sort_cmp(void *a, void *b)
{
    obj_t *at, *bt;
    at = a;
    bt = b;
    return cmp(module_get_render_order(at), module_get_render_order(bt));
}


/*
 * Function: core_get_proj
 * Get the core current view projection
 *
 * Parameters:
 *   proj   - Pointer to a projection_t instance that get initialized.
 */
void core_get_proj(projection_t *proj)
{
    double fovx, fovy;
    double aspect = core->win_size[0] / core->win_size[1];
    projection_compute_fovs(core->proj, core->fov, aspect, &fovx, &fovy);
    projection_init(proj, core->proj, fovx,
                    core->win_size[0], core->win_size[1]);
}

obj_t *core_get_obj_at(double x, double y, double max_dist)
{
    double pos[2] = {x, y};
    uint64_t oid, hint;
    if (!areas_lookup(core->areas, pos, max_dist, &oid, &hint))
        return NULL;
    if (!oid) return NULL;
    return obj_get_by_oid(NULL, oid, hint);
}

EMSCRIPTEN_KEEPALIVE
void core_add_default_sources(void)
{
    #define BASE_URL "https://data.stellarium.org/"
    #define add_source(url, type) \
        module_add_data_source(NULL, url, type, NULL)

    add_source(BASE_URL "landscapes", NULL);

    // Online gaia survey.
    add_source(BASE_URL "surveys/gaia_dr2_v2?v=2019-02-11T05:34Z", "hips");

    // Bundled star survey.
    add_source("asset://stars", "hips");

    // Online DSO survey.
    add_source(BASE_URL "surveys/dso", "hips");

    // Skyculture.  We load the western culture immediately so we don't have
    // to wait to parse the online directory index.json file.
    asset_set_alias(BASE_URL "skycultures", "asset://skycultures");
    add_source(BASE_URL "skycultures/western", "skyculture");
    add_source(BASE_URL "skycultures", NULL);

    // HiPS surveys.
    add_source(BASE_URL "surveys", "hipslist");

    add_source("https://alasky.unistra.fr/DSS/DSSColor", "hips");

    // MPC data.
    add_source("asset://mpcorb.dat", "mpc_asteroids");
    add_source(BASE_URL "mpc/CometEls.txt", "mpc_comets");

    // Artificial satellites files.
    add_source(BASE_URL "norad", "norad");

    #undef ADD_SOURCE
    #undef BASE_URL
}

// Set the default init values.
static void core_set_default(void)
{
    double tsl;
    observer_t *obs = core->observer;

    // Reset to Taipei.
    obj_set_attr(&obs->obj, "latitude", 25.066667 * DD2R);
    obj_set_attr(&obs->obj, "longitude", 121.516667 * DD2R);
    obj_set_attr(&obs->obj, "elevation", 0.0);
    obs->tt = unix_to_mjd(sys_get_unix_time());

    // We approximate the pressure from the altitude and the sea level
    // temperature in K (See Astrophysical Quantities, C.W.Allen, 3rd edition,
    // section 52).
    tsl = 15 + 273.15;  // Let say we have a see level temp of 15 deg C.
    obs->pressure = 1013.25 * exp(-obs->hm / (29.3 * tsl));
    obs->refraction = true;

    core->fov = 90 * DD2R;
    core->utc_offset = sys_get_utc_offset() / 60;

    core->proj = PROJ_STEREOGRAPHIC;
    core->lwmax = 5000;

    // Adjust those values to make the sky look good.
    core->star_linear_scale = 0.5;
    core->star_relative_scale = 1.4;
    core->lwmax_min = 0.004;
    core->lwmax_scale = 13.0;
    core->max_point_radius = 6.0;
    core->min_point_radius = 0.5;
    core->skip_point_radius = 0.2;
    core->lwsky_average = 0.0001;  // Updated by atmosphere rendering
    tonemapper_update(&core->tonemapper, 1, 1, 1, core->lwmax);

    core->telescope_auto = true;
    observer_update(core->observer, false);
}

static void on_progressbar(const char *id)
{
    module_changed((obj_t*)core, "progressbars");
}

// Callback for texture loading.
static uint8_t *texture_load_function(
        void *user, const char *url, int *code,
        int *w, int *h, int *bpp)
{
    const void *data;
    int size;
    data = asset_get_data(url, &size, code);
    if (!data) return NULL;
    return img_read_from_mem(data, size, w, h, bpp);
}

EMSCRIPTEN_KEEPALIVE
void core_init(double win_w, double win_h, double pixel_scale)
{
    char cache_dir[1024];
    obj_klass_t *module;

    if (core) {
        // Already initialized.
        core_set_default();
        return;
    }
    profile_init();
    texture_set_load_callback(NULL, texture_load_function);
    sprintf(cache_dir, "%s/%s", sys_get_user_dir(), ".cache");
    request_init(cache_dir);

    core = (core_t*)obj_create("core", "core", NULL, NULL);
    core->win_size[0] = win_w;
    core->win_size[1] = win_h;
    core->win_pixels_scale = pixel_scale;
    core->hints_mag_offset = -1;

    core->observer = (observer_t*)obj_create("observer", "observer",
                                             (obj_t*)core, NULL);

    for (module = obj_get_all_klasses(); module; module = module->next) {
        if (!(module->flags & OBJ_MODULE)) continue;
        obj_create(module->id, module->id, (obj_t*)core, NULL);
    }
    DL_SORT(core->obj.children, modules_sort_cmp);

    core->areas = areas_create();
    progressbar_add_listener(on_progressbar);

    core_set_default();
}

void core_release(void)
{
    obj_t *module;
    DL_FOREACH(core->obj.children, module) {
        if (module->klass->del) module->klass->del(module);
    }
    profile_release();
}

void core_update_fov(double dt)
{
    double t;
    double save_fov = core->fov;

    if (core->fov_animation.duration) {
        core->fov_animation.t += dt / core->fov_animation.duration;
        t = smoothstep(0.0, 1.0, core->fov_animation.t);
        // Make sure we finish on an exact value.
        if (core->fov_animation.t >= 1.0) t = 1.0;
        if (core->fov_animation.dst_fov) {
            core->fov = mix(core->fov_animation.src_fov,
                            core->fov_animation.dst_fov, t);
        }
        if (core->fov_animation.t >= 1.0) {
            core->fov_animation.duration = 0.0;
            core->fov_animation.t = 0.0;
            core->fov_animation.dst_fov = 0.0;
        }
    }

    projection_t proj;

    const double ZOOM_FACTOR = 0.05;
    // Continuous zoom.
    core_get_proj(&proj);
    if (core->zoom) {
        core->fov *= pow(1. + ZOOM_FACTOR * (-core->zoom), dt/(1./60));
        if (core->fov > proj.max_fov)
            core->fov = proj.max_fov;
    }

    core->fov = clamp(core->fov, CORE_MIN_FOV, proj.max_fov);

    if (core->fov != save_fov)
        module_changed((obj_t*)core, "fov");
}

static int core_update_direction(double dt)
{
    double v[4] = {1, 0, 0, 0}, q[4], t, az, al, vv[4];

    if (core->target.duration) {
        core->target.t += dt / core->target.duration;
        t = smoothstep(0.0, 1.0, core->target.t);
        // Make sure we finish on an exact value.
        if (core->target.t >= 1.0) t = 1.0;
        if (core->target.lock && core->target.move_to_lock) {
            // We are moving toward a potentially moving target, adjust the
            // destination
            obj_get_pos_observed(core->target.lock, core->observer, vv);
            eraC2s((double*)vv, &az, &al);
            quat_set_identity(core->target.dst_q);
            quat_rz(az, core->target.dst_q, core->target.dst_q);
            quat_ry(-al, core->target.dst_q, core->target.dst_q);
        }
        if (!core->target.lock || core->target.move_to_lock) {
            quat_slerp(core->target.src_q, core->target.dst_q, t, q);
            quat_mul_vec3(q, v, v);
            eraC2s(v, &core->observer->azimuth, &core->observer->altitude);
        }
        if (core->target.t >= 1.0) {
            core->target.duration = 0.0;
            core->target.t = 0.0;
            core->target.move_to_lock = false;
        }
        // Notify the changes.
        module_changed(&core->observer->obj, "altitude");
        module_changed(&core->observer->obj, "azimuth");
    }

    if (core->target.lock && !core->target.move_to_lock) {
        obj_get_pos_observed(core->target.lock, core->observer, v);
        eraC2s(v, &core->observer->azimuth, &core->observer->altitude);
        // Notify the changes.
        module_changed(&core->observer->obj, "altitude");
        module_changed(&core->observer->obj, "azimuth");
    }

    return 1;
}

EMSCRIPTEN_KEEPALIVE
int core_update(double dt)
{
    bool atm_visible;
    double lwmax;
    int r;
    obj_t *atm, *module;

    atm = core_get_module("atmosphere");
    assert(atm);
    obj_get_attr(atm, "visible", &atm_visible);
    observer_update(core->observer, true);
    // Update telescope according to the fov.
    if (core->telescope_auto)
        telescope_auto(&core->telescope, core->fov);
    progressbar_update();

    // Update eye adaptation.
    lwmax = core->lwmax * core->lwmax_scale;
    lwmax = exp(logf(core->tonemapper.lwmax) +
                (logf(lwmax) - logf(core->tonemapper.lwmax)) *
                min(0.05 * dt / 0.01666, 0.5));
    tonemapper_update(&core->tonemapper, -1, -1, -1, lwmax);
    core->lwmax = core->lwmax_min; // Reset for next frame.

    // Adjust star linear scale in function of screen pixel size
    // It ranges from 0.5 for a small screen to 1.4 for large screens
    double delta = -1.0 + min(core->win_size[0], core->win_size[1]) / 400;
    delta = min(max(0, delta), 0.9);
    core->star_linear_scale = 0.5 + delta;

    core_update_direction(dt);

    DL_SORT(core->obj.children, modules_sort_cmp);
    DL_FOREACH(core->obj.children, module) {
        if (module->klass->update) {
            r = module->klass->update(module, dt);
            if (r < 0) LOG_E("Error updating module '%s'", module->id);
        }
    }

    return 0;
}

// Test whether the landscape hides the view below the horizon.
static bool is_below_horizon_hidden(void)
{
    obj_t *ls;
    bool visible;
    ls = core_get_module("landscapes");
    obj_get_attr(ls, "visible", &visible);
    // XXX: we should let the lanscape module notify the core that it hides
    // the stars instead.
    return (visible && core->observer->altitude >= 0);
}

/*
 * Compute the magnitude of the dimmest visible star.
 */
static double compute_max_vmag(void)
{
    // Compute by dichotomy.
    const int max_iter = 16;
    const double min_l = 0.1;
    double m = 0, m1 = 0.0, m2 = 128.0;
    double r, l;
    int i;

    core_get_point_for_mag(m1, &r, &l);
    if (r == 0) return m1;

    for (i = 0; i < max_iter; i++) {
        m = (m1 + m2) / 2;
        core_get_point_for_mag(m, &r, &l);
        if (r && l < min_l) return m;
        *(r ? &m1 : &m2) = m;
    }
    // if (i >= max_iter) LOG_W("Too many iterations! (%f)", m);
    return m;
}

/*
 * Function: win_to_observed
 * Convert a window 2D position to a 3D azalt direction.
 *
 * Parameters:
 *   x    - The window x position.
 *   y    - The window y position.
 *   p    - Corresponding 3D unit vector in azalt (after refraction).
 */
static void win_to_observed(double x, double y, double p[3])
{
    projection_t proj;
    double pos[4] = {x, y};

    core_get_proj(&proj);
    // Convert to NDC coordinates.
    pos[0] = pos[0] / core->win_size[0] * 2 - 1;
    pos[1] = -1 * (pos[1] / core->win_size[1] * 2 - 1);
    project(&proj, PROJ_BACKWARD, 4, pos, pos);
    convert_frame(core->observer, FRAME_VIEW, FRAME_OBSERVED, true, pos, p);
}


EMSCRIPTEN_KEEPALIVE
int core_render(double win_w, double win_h, double pixel_scale)
{
    PROFILE(core_render, 0);
    obj_t *module;
    projection_t proj;
    double t;
    bool cst_visible;
    double max_vmag;

    // Used to make sure some values are not touched during render.
    struct {
        observer_t obs;
        double fov;
    } bck = {
        .obs = *core->observer,
        .fov = core->fov,
    };
    (void)bck;

    core->win_size[0] = win_w;
    core->win_size[1] = win_h;
    core->win_pixels_scale = pixel_scale;
    core_get_proj(&proj);

    observer_update(core->observer, true);
    max_vmag = compute_max_vmag();

    t = sys_get_unix_time();
    if (!core->prof.start_time) core->prof.start_time = t;
    // Reset counter every 60 frames.
    if (core->prof.nb_frames++ >= 60) {
        core->prof.fps = core->prof.nb_frames / (t - core->prof.start_time);
        module_changed(&core->obj, "fps");
        core->prof.start_time = t;
        core->prof.nb_frames = 0;
    }

    if (!core->rend)
        core->rend = render_gl_create();
    labels_reset();

    // Show bayer only if the constellations lines are visible.
    module = core_get_module("constellations");
    assert(module);
    obj_get_attr(module, "lines_visible", &cst_visible);

    painter_t painter = {
        .rend = core->rend,
        .obs = core->observer,
        .transform = &mat4_identity,
        .fb_size = {win_w * pixel_scale, win_h * pixel_scale},
        .pixel_scale = pixel_scale,
        .proj = &proj,
        .stars_limit_mag = max_vmag,
        .hints_limit_mag = max_vmag + core->hints_mag_offset,
        .points_smoothness = 0.75,
        .color = {1.0, 1.0, 1.0, 1.0},
        .contrast = 1.0,
        .lines_width = 1.0,
        .flags = (core->fast_mode ? PAINTER_FAST_MODE : 0) |
            (is_below_horizon_hidden() ? PAINTER_HIDE_BELOW_HORIZON : 0) |
            PAINTER_SHOW_BAYER_LABELS,
    };
    painter_update_caps(&painter);
    paint_prepare(&painter, win_w, win_h, pixel_scale);

    DL_FOREACH(core->obj.children, module) {
        obj_render(module, &painter);
    }

    // Render the viewport cap for debugging.
    if ((0)) {
        paint_cap(&painter, FRAME_ICRF, painter.viewport_caps[FRAME_ICRF]);
    }

    // Flush all rendering pipeline
    paint_finish(&painter);

    // Do post render (e.g. for GUI)
    DL_FOREACH(core->obj.children, module) {
        if (module->klass->post_render)
            module->klass->post_render(module, &painter);
    }

    core->fast_mode = false;

    assert(bck.obs.azimuth == core->observer->azimuth);
    assert(bck.obs.altitude == core->observer->altitude);
    assert(bck.fov == core->fov);
    return 0;
}

EMSCRIPTEN_KEEPALIVE
void core_on_mouse(int id, int state, double x, double y)
{
    obj_t *module;
    DL_FOREACH(core->obj.children, module) {
        if (module->klass->on_mouse) {
            module->klass->on_mouse(module, id, state, x, y);
        };
    }
}

EMSCRIPTEN_KEEPALIVE
void core_on_key(int key, int action)
{
    static char *SC[][3] = {
        {"A", "core.atmosphere"},
        {"G", "core.landscapes"},
        {"F", "core.landscapes", "fog_visible"},
        {"C", "core.constellations", "lines_visible"},
        {"R", "core.constellations", "images_visible"},
        {"Z", "core.lines.azimuthal"},
        {"E", "core.lines.equatorial"},
        {"M", "core.lines.meridian"},
        {"N", "core.dsos"},
        {"D", "core.dss"},
        {"S", "core.stars"},
        {"T", "core", "test"},
    };
    int i;
    bool v;
    obj_t *module;
    const char *attr;
    char buf[128];

    core->inputs.keys[key] = (action != KEY_ACTION_UP);

    if (core->gui_want_capture_mouse) return;
    if (action != KEY_ACTION_DOWN) return;

    for (i = 0; i < ARRAY_SIZE(SC); i++) {
        if (SC[i][0][0] == key) {
            attr = SC[i][2] ?: "visible";
            module = core_get_module(SC[i][1]);
            obj_get_attr(module, attr, &v);
            obj_set_attr(module, attr, !v);
            return;
        }
    }
    if (key == ' ' && core->selection) {
        LOG_D("lock to %s", obj_get_name(core->selection, buf));
        obj_set_attr(&core->obj, "lock", core->selection);
    }
}

void core_on_char(uint32_t c)
{
    int i;
    if (c > 0 && c < 0x10000) {
        for (i = 0; i < ARRAY_SIZE(core->inputs.chars); i++) {
            if (!core->inputs.chars[i]) {
                core->inputs.chars[i] = c;
                break;
            }
        }
    }
}

EMSCRIPTEN_KEEPALIVE
void core_on_zoom(double k, double x, double y)
{
    double fov, pos_start[3], pos_end[3];
    double sal, saz, dal, daz;

    win_to_observed(x, y, pos_start);
    obj_get_attr(&core->obj, "fov", &fov);
    fov /= k;
    obj_set_attr(&core->obj, "fov", fov);
    win_to_observed(x, y, pos_end);

    // Adjust lat/az to keep the mouse point at the same position.
    eraC2s(pos_start, &saz, &sal);
    eraC2s(pos_end, &daz, &dal);
    core->observer->azimuth += (saz - daz);
    core->observer->altitude += (sal - dal);
    core->observer->altitude = clamp(core->observer->altitude,
                                     -M_PI / 2, +M_PI / 2);
    core->fast_mode = true;
    // Notify the changes.
    module_changed(&core->observer->obj, "altitude");
    module_changed(&core->observer->obj, "azimuth");
}


/*
 * Function: core_get_point_for_mag
 * Compute a point radius and luminosity from a observed magnitude.
 *
 * The function is almost linear, but when the points get too small,
 * I make the curve go to zero faster, so that the bright stars get a
 * higher contrast.  Also for very small points, we use a minimum radius
 * and instead lower the luminance.
 *
 * Parameters:
 *   mag       - The observed magnitude.
 *   radius    - Output radius in window pixels.
 *   luminance - Output luminance from 0 to 1, gamma corrected.  Ignored if
 *               set to NULL.
 */
void core_get_point_for_mag(double mag, double *radius, double *luminance)
{

    /*
     * Use the formulas from:
     * https://en.wikipedia.org/wiki/Surface_brightness
     */

    double log_e, log_lw, ld, r, pr;
    const telescope_t *tel = &core->telescope;
    const double s_linear = core->star_linear_scale;
    const double s_relative = core->star_relative_scale;
    const double r_min = core->min_point_radius;

    /*
     * Compute illuminance (in lux = lum/mÂ² = cd.sr/mÂ²)
     * Get log10 of the value for optimisation.
     *
     * S = m + 2.5 * log10(A)         | S: Surface Brightness (vmag/arcminÂ²)
     *                                | A: visual area of source (arcminÂ²)
     *                                | m: source magnitude integrated over A
     * L = 10.8e4 * 10^(-0.4 * S)     | S: vmag/arcminÂ², L: luminance (cd/mÂ²)
     * E = L * A                      | E: lux (= cd.sr/mÂ²), A: sr, L: cd/mÂ²
     *
     * => E = 10.8e4 / R2AS^2 * 10^(-0.4 * m)
     * => log10(E) = log10(10.8e4 / R2AS^2) - 0.4 * m
     *
     * Same formula at https://en.wikipedia.org/wiki/Illuminance
     */
    log_e = log10(10.8e4 / (ERFA_DR2AS * ERFA_DR2AS)) - 0.4 * mag;

    /*
     * Apply optic from telescope light grasp (Gl).
     *
     * E' = E * Gl
     * Gmag = 2.5 * log10(Gl)
     *
     * Log10(E') = Log10(E) + Gmag / 2.5
     */
    log_e += tel->gain_mag / 2.5;

    /*
     * Compute luminance assuming a point radius of 2.5 arcmin.
     *
     * L = E / (pi * R^2)
     * => Log10(L) = Log10(E) - Log10(pi * R^2)
     */
    pr = 2.5 / 60 * DD2R;
    log_lw = log_e - log10(M_PI * pr * pr);

    // Apply eye adaptation.
    ld = tonemapper_map_log10(&core->tonemapper, log_lw);
    if (ld < 0) ld = 0; // Prevent math error.

    // Compute r, using both manual adjustement factors.
    r = s_linear * pow(ld, s_relative / 2.0);

    // If the radius is really too small, we don't render the star.
    if (r < core->skip_point_radius) {
        r = 0;
        ld = 0;
    }

    // If the radius is too small, we adjust the luminance.
    if (r > 0 && r < r_min) {
        ld *= (r / r_min) * (r / r_min) * (r / r_min);
        r = r_min;
    }

    ld = pow(ld, 1 / 2.2); // Gama correction.
    // Saturate radius after a certain point.
    // XXX: make it smooth.
    r = min(r, core->max_point_radius);
    *radius = r;
    if (luminance) *luminance = clamp(ld, 0, 1);
}


/*
 * Function: core_get_apparent_angle_for_point
 * Get angular radius of a round object from it's pixel radius on screen.
 *
 * For example this can be used after core_get_point_for_mag to estimate the
 * angular size a circle should have to exactly fit the object.
 *
 * Parameters:
 *   proj   - The projection used.
 *   r      - Radius on screen in window pixels.
 *
 * Return:
 *   Angular radius in radian.  This is the physical radius, not scaled by
 *   the fov.
 */
double core_get_apparent_angle_for_point(const projection_t *proj, double r)
{
    const double win_w = proj->window_size[0];
    return r * proj->scaling[0] / win_w * 2;
}

/*
 * Function: core_report_vmag_in_fov
 * Inform the core that an object with a given vmag is visible.
 *
 * This is used for the eyes adaptations algo.
 *
 * Parameters:
 *   vmag - The magnitude of the object.
 *   r    - Visible radius of the object (rad).
 *   sep  - Separation of the center of the object to the center of the
 *          screen.
 */
void core_report_vmag_in_fov(double vmag, double r, double sep)
{
    double lf, lum, r2;

    // Compute flux and luminance.
    vmag -= core->telescope.gain_mag;
    // E = 10.8e4 / R2AS^2 * 10^(-0.4 * m)
    // m: source magnitude integrated over A
    // E: lux (= cd.sr/mÂ²), A: sr, L: cd/mÂ²
    lf = 10.8e4 / (ERFA_DR2AS * ERFA_DR2AS) * pow(10, -0.4 * vmag);

    // L = E / A
    lum = lf / (M_PI * r * r);

    // Radius as seen from the observer eye in the eye piece
    r2 = r * core->telescope.magnification;

    // Make sure the observed radius can't be smaller as point source radius
    // assumed to be 2.5 arcmin (see formula in above function)
    r2 = max(r2, 2.5 / 60 * DD2R);

    // The following 3 lines are 100% ad-hoc formulas adjusted so that:
    // - the moon should render all but bright stars invisible
    // - mars should hide most stars and DSS when zoomed

    // Modulate final luminance by the ratio of area covered by the object
    // in eyepiece field of view (which is always assumed to be 60 deg FOV).
    lum *= pow(r2 / (60 * DD2R), 1.2);
    lum = pow(lum, 0.33);
    lum /= 400;

    lum *= smoothstep(core->fov * 0.75, 0, max(0, sep - r));
    core_report_luminance_in_fov(lum, false);
}

void core_report_luminance_in_fov(double lum, bool fast_adaptation)
{
    core->lwmax = max(core->lwmax, lum);
    if (fast_adaptation && core->lwmax > core->tonemapper.lwmax) {
        tonemapper_update(&core->tonemapper, -1, -1, -1,
                          core->lwmax * core->lwmax_scale);
    }
}

static int do_core_lookat(double* pos, double duration) {
    double az, al;

    // Direct lookat.
    if (duration == 0.0) {
        eraC2s(pos, &core->observer->azimuth, &core->observer->altitude);
        return 0;
    }

    quat_set_identity(core->target.src_q);
    quat_rz(core->observer->azimuth, core->target.src_q, core->target.src_q);
    quat_ry(-core->observer->altitude, core->target.src_q, core->target.src_q);

    eraC2s((double*)pos, &az, &al);
    quat_set_identity(core->target.dst_q);
    quat_rz(az, core->target.dst_q, core->target.dst_q);
    quat_ry(-al, core->target.dst_q, core->target.dst_q);

    core->target.duration = duration;
    core->target.t = 0.0;
    core->fast_mode = true;
    return 0;
}

static json_value *core_point_and_lock(obj_t *obj, const attribute_t *attr,
                               const json_value *args)
{
    double v[4], duration = 1.0;
    obj_t* target_obj;
    args_get(args, "target", 1, TYPE_OBJ, &target_obj);
    args_get(args, "speed", 2, TYPE_FLOAT, &duration);

    obj_set_attr(&core->obj, "lock", target_obj);

    obj_get_pos_observed(core->target.lock, core->observer, v);
    do_core_lookat(v, duration);
    core->target.move_to_lock = true;
    return NULL;
}

static json_value *core_lookat(obj_t *obj, const attribute_t *attr,
                               const json_value *args)
{
    // XXX find a better way to create a rot quaternion from a direction?
    double duration = 1.0, pos[3];

    args_get(args, "target", 1, TYPE_V3, pos);
    args_get(args, "speed", 2, TYPE_FLOAT, &duration);

    do_core_lookat(pos, duration);
    return NULL;
}

static json_value *core_zoomto(obj_t *obj, const attribute_t *attr,
                               const json_value *args)
{
    double duration = 1.0, fov = 0.0;

    args_get(args, "fov", 1, TYPE_ANGLE, &fov);
    args_get(args, "speed", 2, TYPE_FLOAT, &duration);

    projection_t proj;
    core_get_proj(&proj);
    if (fov > proj.max_fov)
        fov = proj.max_fov;

    // Direct lookat.
    if (duration == 0.0) {
        core->fov = fov;
        return NULL;
    }

    typeof(core->fov_animation)* anim = &core->fov_animation;
    if (anim->t < 1 && anim->t > 0) {
        // We request a new animation while another one is still on going
        if (fov == anim->dst_fov) {
            // Same animation is going on, just finish it
            return NULL;
        }
        // We are looking for a new set of zoom parameters so that:
        // - we preserve the current zoom level
        // - the remaining animation time is equal to the new duration
        double t2 = (anim->t * anim->duration) / (anim->t * anim->duration +
                                                  duration);
        assert(t2 >= 0 && t2 <= 1);
        double st2 = smoothstep(0, 1, t2);
        double src2 = (core->fov - fov * st2) / (1.0 - st2);
        anim->src_fov = src2;
        anim->dst_fov = fov;
        anim->duration = anim->t * anim->duration + duration;
        anim->t = t2;
        return NULL;
    }

    anim->src_fov = core->fov;
    anim->dst_fov = fov;
    anim->duration = duration;
    anim->t = 0.0;

    return NULL;
}

// Return a static string representation of a an object type id.
// XXX: deprecated.  Use otypes_get_str instead.
EMSCRIPTEN_KEEPALIVE
const char *type_to_str(const char type[4])
{
    const char *explanation;
    explanation = otype_get_str(type);
    if (explanation) return explanation;

    // Most of yhose values should eventually be removed, since we are now
    // using Simbad types everywhere.
    static const char *TABLE[][2] = {
        // XXX: some are from NGC2000 and could be removed.
        {"Gx  ", "Galaxy"},
        {"OC  ", "Open star cluster"},
        {"Gb  ", "Globular star cluster"},
        {"Nb  ", "Bright emission or reflection nebula"},
        {"Pl  ", "Planetary nebula"},
        {"C+N ", "Cluster associated with nebulosity"},
        {"Ast ", "Asterism or group of a few stars"},
        {"Kt  ",  "Knot or nebulous region in an external galaxy"},
        {"*** ", "Triple star"},
        {"D*  ",  "Double star"},
        {"*   ",   "Star"},
        {"PD  ",  "Photographic plate defect"},

        {"PLA ", "Planet"},
        {"MOO ", "Moon"},
        {"SUN ", "Sun"},

        // From OpenNGC
        {"*Ass", "Association of stars"},
        {"OCl ", "Open Cluster"},
        {"GCl ", "Globular Cluster"},
        {"Cl+N", "Star cluster + Nebula"},
        {"G   ", "Galaxy"},
        {"GPai", "Galaxy Pair"},
        {"GTrp", "Galaxy Triplet"},
        {"GGro", "Group of galaxies"},
        {"PN  ", "Planetary Nebula"},
        {"HII ", "HII Ionized region"},
        {"EmN ", "Emission Nebula"},
        {"Neb ", "Nebula"},
        {"RfN ", "Reflection Nebula"},
        {"SNR ", "Supernova remnant"},
        {"Nova", "Nova star"},
        {"NonE", "Nonexistent object"},
    };
    int i;
    char t[4] = "    ";
    memcpy(t, type, strlen(type));
    for (i = 0; i < ARRAY_SIZE(TABLE); i++) {
        if (strncmp(t, TABLE[i][0], 4) == 0)
            return TABLE[i][1];
    }
    return "?";
}

static obj_klass_t core_klass = {
    .id = "core",
    .size = sizeof(core_t),
    .flags = OBJ_IN_JSON_TREE,
    .get = core_get,
    .get_by_oid = core_get_by_oid,
    .list = core_list,
    .add_data_source = core_add_data_source,
    .attributes = (attribute_t[]) {
        PROPERTY(utcoffset, TYPE_INT, MEMBER(core_t, utc_offset),
                 .on_changed = core_on_utcoffset_changed),
        PROPERTY(fov, TYPE_ANGLE, MEMBER(core_t, fov),
                 .on_changed = core_on_fov_changed),
        PROPERTY(projection, TYPE_INT, MEMBER(core_t, proj)),
        PROPERTY(selection, TYPE_OBJ, MEMBER(core_t, selection)),
        PROPERTY(lock, TYPE_OBJ, MEMBER(core_t, target.lock)),
        PROPERTY(hovered, TYPE_OBJ, MEMBER(core_t, hovered)),
        PROPERTY(hints_mag_offset, TYPE_MAG, MEMBER(core_t, hints_mag_offset)),
        PROPERTY(progressbars, TYPE_JSON, .fn = core_fn_progressbars),
        PROPERTY(fps, TYPE_FLOAT, MEMBER(core_t, prof.fps)),
        PROPERTY(clicks, TYPE_INT, MEMBER(core_t, clicks)),
        PROPERTY(ignore_clicks, TYPE_BOOL, MEMBER(core_t, ignore_clicks)),
        PROPERTY(zoom, TYPE_FLOAT, MEMBER(core_t, zoom)),
        PROPERTY(test, TYPE_BOOL, MEMBER(core_t, test)),
        FUNCTION(lookat, .fn = core_lookat),
        FUNCTION(point_and_lock, .fn = core_point_and_lock),
        FUNCTION(zoomto, .fn = core_zoomto),
        {}
    }
};
OBJ_REGISTER(core_klass)

/******* TESTS **********************************************************/

#if COMPILE_TESTS

// Some tests of vec/mat functions.
static void test_vec(void)
{
    double mat[4][4];
    double e = 0.0000001;
    mat4_set_identity(mat);
    mat4_rx(M_PI / 2, mat, mat);
    assert(vec3_dist2(mat[0], (double[]){1,  0, 0}) < e);
    assert(vec3_dist2(mat[1], (double[]){0,  0, 1}) < e);
    assert(vec3_dist2(mat[2], (double[]){0, -1, 0}) < e);

    mat4_invert(mat, mat);
    assert(vec3_dist2(mat[0], (double[]){1, 0, 0}) < e);
    assert(vec3_dist2(mat[1], (double[]){0, 0, -1}) < e);
    assert(vec3_dist2(mat[2], (double[]){0, 1, 0}) < e);
}

static void test_core(void)
{
    double v;
    core_init(100, 100, 1.0);
    core->observer->hm = 10.0;
    obj_t *obs = core_get_module("observer");
    assert(obs);
    obj_get_attr(obs, "elevation", &v); assert(v == 10.0);
    obj_set_attr(obs, "longitude", 1.0);
    assert(core->observer->elong == 1.0);
    obj_get_attr(obs, "longitude", &v); assert(v == 1.0);
    obj_get_attr(obs, "utc", &v);
}

static void test_basic(void)
{
    obj_t *obj;
    // Test search bright star by HIP:
    obj = obj_get(NULL, "HIP 677", 0);
    assert(obj);
    obj_release(obj);
    // Test obj_get with '|'
    obj = obj_get(NULL, "No result|Sun", 0);
    assert(obj);
    obj_release(obj);
}

static void test_set_city(void)
{
    double lat;
    core_init(100, 100, 1.0);
    obj_t *cities, *london;
    obj_t *obs = &core->observer->obj;

    cities = core_get_module("cities");
    assert(cities);
    // Make sure that after we set the city, the position has been updated.
    london = module_get_child(cities, "CITY GB LONDON");
    assert(london);
    obj_get_attr(london, "latitude", &lat);
    assert(fabs(lat * DR2D - 51.50853) < 0.01);
    obj_set_attr(obs, "city", london);
    obj_get_attr(obs, "latitude", &lat);
    assert(fabs(lat * DR2D - 51.50853) < 0.01);
    obj_get_attr(obs, "city", &london);
    assert(london == core->observer->city);
}

TEST_REGISTER(NULL, test_core, TEST_AUTO);
TEST_REGISTER(NULL, test_vec, TEST_AUTO);
TEST_REGISTER(NULL, test_basic, TEST_AUTO);
TEST_REGISTER(NULL, test_set_city, TEST_AUTO);

#endif
